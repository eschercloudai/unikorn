// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/r/7fgHdPs/CNpv/BgAA//8BXr90gEUAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
