// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
