// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package generated

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	Oauth2AuthenticationScopes = "oauth2Authentication.Scopes"
)

// Defines values for Oauth2ErrorError.
const (
	AccessDenied            Oauth2ErrorError = "access_denied"
	Conflict                Oauth2ErrorError = "conflict"
	Forbidden               Oauth2ErrorError = "forbidden"
	InvalidClient           Oauth2ErrorError = "invalid_client"
	InvalidGrant            Oauth2ErrorError = "invalid_grant"
	InvalidRequest          Oauth2ErrorError = "invalid_request"
	InvalidScope            Oauth2ErrorError = "invalid_scope"
	MethodNotAllowed        Oauth2ErrorError = "method_not_allowed"
	NotFound                Oauth2ErrorError = "not_found"
	ServerError             Oauth2ErrorError = "server_error"
	TemporarilyUnavailable  Oauth2ErrorError = "temporarily_unavailable"
	UnauthorizedClient      Oauth2ErrorError = "unauthorized_client"
	UnsupportedGrantType    Oauth2ErrorError = "unsupported_grant_type"
	UnsupportedMediaType    Oauth2ErrorError = "unsupported_media_type"
	UnsupportedResponseType Oauth2ErrorError = "unsupported_response_type"
)

// ApplicationBundle A bundle of applications. This forms the basis of resource versions. Bundles marked
// as preview should not be selected by default, and end of life bundles should not be
// used to avoid unnecessary upgrades. If enabled, automatic upgrades will occur if
// a newer version of a bundle exists that is not in preview. When a bundle's end of
// life expires, resources will undergo a foreced upgrade, regardless of whether
// automatic upgrade is enabled for a resource or not.
type ApplicationBundle struct {
	// EndOfLife When the bundle is end-of-life.
	EndOfLife *time.Time `json:"endOfLife,omitempty"`

	// Name The resource name.
	Name string `json:"name"`

	// Preview Whether the bundle is in preview.
	Preview *bool `json:"preview,omitempty"`

	// Version The bundle version.
	Version string `json:"version"`
}

// ApplicationBundleAutoUpgrade When specified, enables auto upgrade of application bundles. All resources will be
// automatically upgraded if the currently selected bundle is end of life.
type ApplicationBundleAutoUpgrade struct {
	// DaysOfWeek Days of the week and time windows that permit operations to be performed in.
	DaysOfWeek *AutoUpgradeDaysOfWeek `json:"daysOfWeek,omitempty"`
}

// ApplicationBundles A list of application bundles.
type ApplicationBundles = []ApplicationBundle

// AutoUpgradeDaysOfWeek Days of the week and time windows that permit operations to be performed in.
type AutoUpgradeDaysOfWeek struct {
	// Friday A time window that wraps into the next day if required.
	Friday *TimeWindow `json:"friday,omitempty"`

	// Monday A time window that wraps into the next day if required.
	Monday *TimeWindow `json:"monday,omitempty"`

	// Saturday A time window that wraps into the next day if required.
	Saturday *TimeWindow `json:"saturday,omitempty"`

	// Sunday A time window that wraps into the next day if required.
	Sunday *TimeWindow `json:"sunday,omitempty"`

	// Thursday A time window that wraps into the next day if required.
	Thursday *TimeWindow `json:"thursday,omitempty"`

	// Tuesday A time window that wraps into the next day if required.
	Tuesday *TimeWindow `json:"tuesday,omitempty"`

	// Wednesday A time window that wraps into the next day if required.
	Wednesday *TimeWindow `json:"wednesday,omitempty"`
}

// ControlPlane A control plane.
type ControlPlane struct {
	// ApplicationBundle A bundle of applications. This forms the basis of resource versions. Bundles marked
	// as preview should not be selected by default, and end of life bundles should not be
	// used to avoid unnecessary upgrades. If enabled, automatic upgrades will occur if
	// a newer version of a bundle exists that is not in preview. When a bundle's end of
	// life expires, resources will undergo a foreced upgrade, regardless of whether
	// automatic upgrade is enabled for a resource or not.
	ApplicationBundle ApplicationBundle `json:"applicationBundle"`

	// ApplicationBundleAutoUpgrade When specified, enables auto upgrade of application bundles. All resources will be
	// automatically upgraded if the currently selected bundle is end of life.
	ApplicationBundleAutoUpgrade *ApplicationBundleAutoUpgrade `json:"applicationBundleAutoUpgrade,omitempty"`

	// Name The name of the resource.
	Name string `json:"name"`

	// Status A Kubernetes resource status.
	Status *KubernetesResourceStatus `json:"status,omitempty"`
}

// ControlPlanes A list of control planes.
type ControlPlanes = []ControlPlane

// Hour An hour of the day in UTC.
type Hour = int

// JsonWebKey JSON web key. See the relevant JWKS documentation for further details.
type JsonWebKey = map[string]interface{}

// JsonWebKeySet JSON web key set. This data type is defined by an external 3rd party standards
// committee. Consult the relevant documentation for further details.
type JsonWebKeySet struct {
	Keys *[]JsonWebKey `json:"keys,omitempty"`
}

// KubernetesCluster Kubernetes cluster creation parameters.
type KubernetesCluster struct {
	// Api Kubernetes API settings.
	Api *KubernetesClusterAPI `json:"api,omitempty"`

	// ApplicationBundle A bundle of applications. This forms the basis of resource versions. Bundles marked
	// as preview should not be selected by default, and end of life bundles should not be
	// used to avoid unnecessary upgrades. If enabled, automatic upgrades will occur if
	// a newer version of a bundle exists that is not in preview. When a bundle's end of
	// life expires, resources will undergo a foreced upgrade, regardless of whether
	// automatic upgrade is enabled for a resource or not.
	ApplicationBundle ApplicationBundle `json:"applicationBundle"`

	// ApplicationBundleAutoUpgrade When specified, enables auto upgrade of application bundles. All resources will be
	// automatically upgraded if the currently selected bundle is end of life.
	ApplicationBundleAutoUpgrade *ApplicationBundleAutoUpgrade `json:"applicationBundleAutoUpgrade,omitempty"`

	// ControlPlane A Kubernetes cluster machine.
	ControlPlane OpenstackMachinePool `json:"controlPlane"`

	// Features A set of optional add on features for the cluster.
	Features *KubernetesClusterFeatures `json:"features,omitempty"`

	// Name Cluster name.
	Name string `json:"name"`

	// Network A kubernetes cluster network settings.
	Network KubernetesClusterNetwork `json:"network"`

	// Openstack Kubernetes cluster creation OpenStack parameters.
	Openstack KubernetesClusterOpenStack `json:"openstack"`

	// Status A Kubernetes resource status.
	Status *KubernetesResourceStatus `json:"status,omitempty"`

	// WorkloadPools A list of Kubernetes cluster workload pools.
	WorkloadPools KubernetesClusterWorkloadPools `json:"workloadPools"`
}

// KubernetesClusterAPI Kubernetes API settings.
type KubernetesClusterAPI struct {
	// AllowedPrefixes Set of address prefixes to allow access to the Kubernetes API.
	AllowedPrefixes *[]string `json:"allowedPrefixes,omitempty"`

	// SubjectAlternativeNames Set of non-standard X.509 SANs to add to the API certificate.
	SubjectAlternativeNames *[]string `json:"subjectAlternativeNames,omitempty"`
}

// KubernetesClusterAutoscaling A Kubernetes cluster workload pool autoscaling configuration. Cluster autoscaling
// must also be enabled in the cluster features.
type KubernetesClusterAutoscaling struct {
	// MaximumReplicas The maximum number of replicas to allow. Must be greater than the minimum.
	MaximumReplicas int `json:"maximumReplicas"`

	// MinimumReplicas The minimum number of replicas to allow. Must be less than the maximum.
	MinimumReplicas int `json:"minimumReplicas"`
}

// KubernetesClusterFeatures A set of optional add on features for the cluster.
type KubernetesClusterFeatures struct {
	// Autoscaling Enable auto-scaling.
	Autoscaling *bool `json:"autoscaling,omitempty"`

	// CertManager Enable cert-manager.
	CertManager *bool `json:"certManager,omitempty"`

	// FileStorage Enable POSIX file based persistent storage (Longhorn).
	FileStorage *bool `json:"fileStorage,omitempty"`

	// Ingress Enable an ingress controller.
	Ingress *bool `json:"ingress,omitempty"`

	// KubernetesDashboard Enable the Kubernetes dashboard.  Requires ingress and certManager to be enabled.
	KubernetesDashboard *bool `json:"kubernetesDashboard,omitempty"`

	// Prometheus Enable Prometheus.
	Prometheus *bool `json:"prometheus,omitempty"`
}

// KubernetesClusterNetwork A kubernetes cluster network settings.
type KubernetesClusterNetwork struct {
	// DnsNameservers A list of DNS name server to use.
	DnsNameservers []string `json:"dnsNameservers"`

	// NodePrefix Network prefix to provision nodes in. Must be a valid CIDR block.
	NodePrefix string `json:"nodePrefix"`

	// PodPrefix Network prefix to provision pods in. Must be a valid CIDR block.
	PodPrefix string `json:"podPrefix"`

	// ServicePrefix Network prefix to provision services in. Must be a valid CIDR block.
	ServicePrefix string `json:"servicePrefix"`
}

// KubernetesClusterOpenStack Kubernetes cluster creation OpenStack parameters.
type KubernetesClusterOpenStack struct {
	// ComputeAvailabilityZone Compute availability zone for control plane, and workload pool default.
	ComputeAvailabilityZone string `json:"computeAvailabilityZone"`

	// ExternalNetworkID OpenStack external network ID.
	ExternalNetworkID string `json:"externalNetworkID"`

	// SshKeyName OpenStack SSH Key to install on all machines.
	SshKeyName *string `json:"sshKeyName,omitempty"`

	// VolumeAvailabilityZone Volume availability zone for control plane, and workload pool default.
	VolumeAvailabilityZone string `json:"volumeAvailabilityZone"`
}

// KubernetesClusterWorkloadPool A Kuberntes cluster workload pool.
type KubernetesClusterWorkloadPool struct {
	// Autoscaling A Kubernetes cluster workload pool autoscaling configuration. Cluster autoscaling
	// must also be enabled in the cluster features.
	Autoscaling *KubernetesClusterAutoscaling `json:"autoscaling,omitempty"`

	// AvailabilityZone Workload pool availability zone. Overrides the cluster default.
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	// Labels Workload pool key value labels to apply on node creation.
	Labels *map[string]string `json:"labels,omitempty"`

	// Machine A Kubernetes cluster machine.
	Machine OpenstackMachinePool `json:"machine"`

	// Name Workload pool name.
	Name string `json:"name"`
}

// KubernetesClusterWorkloadPools A list of Kubernetes cluster workload pools.
type KubernetesClusterWorkloadPools = []KubernetesClusterWorkloadPool

// KubernetesClusters A list of Kubernetes clusters.
type KubernetesClusters = []KubernetesCluster

// KubernetesNameParameter A Kubernetes name. Must be a valid DNS containing only lower case characters, numbers or hyphens, start and end with a character or number, and be at most 63 characters in length.
type KubernetesNameParameter = string

// KubernetesResourceStatus A Kubernetes resource status.
type KubernetesResourceStatus struct {
	// CreationTime The time the resource was created.
	CreationTime time.Time `json:"creationTime"`

	// DeletionTime The time the resource was deleted.
	DeletionTime *time.Time `json:"deletionTime,omitempty"`

	// Name The name of the resource.
	Name string `json:"name"`

	// Status The current status of the resource. Intially the status will be "Unknown" until
	// the resource is reconciled by the relevant controller. It then will transition to
	// "Provisioning" and will be ready for use when it changes to "Provisioned". The status
	// will also transition to the "Provisioning" status during an update. The
	// status will change to "Deprovisioning" when a delete request is being processed.
	// It may also change to "Error" if an unexpected error occurred during any operation.
	// Errors may be transient.
	Status string `json:"status"`
}

// Oauth2Error Generic error message.
type Oauth2Error struct {
	// Error A terse error string expanding on the HTTP error code. Errors are based on the OAuth2 specification, but are expanded with proprietary status codes for APIs other than those specified by OAuth2.
	Error Oauth2ErrorError `json:"error"`

	// ErrorDescription Verbose message describing the error.
	ErrorDescription string `json:"error_description"`
}

// Oauth2ErrorError A terse error string expanding on the HTTP error code. Errors are based on the OAuth2 specification, but are expanded with proprietary status codes for APIs other than those specified by OAuth2.
type Oauth2ErrorError string

// OpenstackAvailabilityZone An OpenStack availability zone.
type OpenstackAvailabilityZone struct {
	// Name The availability zone name.
	Name string `json:"name"`
}

// OpenstackAvailabilityZones A list of OpenStack availability zones.
type OpenstackAvailabilityZones = []OpenstackAvailabilityZone

// OpenstackExternalNetwork An OpenStack external network.
type OpenstackExternalNetwork struct {
	// Id OpenStack external network ID.
	Id string `json:"id"`

	// Name Opestack external network name.
	Name string `json:"name"`
}

// OpenstackExternalNetworks A list of OpenStack external networks.
type OpenstackExternalNetworks = []OpenstackExternalNetwork

// OpenstackFlavor An OpenStack flavor.
type OpenstackFlavor struct {
	// Cpus The number of CPUs.
	Cpus int `json:"cpus"`

	// Disk The amount of ephemeral disk in GB.
	Disk int `json:"disk"`

	// Gpus The number of GPUs, if not set there are none.
	Gpus *int `json:"gpus,omitempty"`

	// Id The unique flavor ID.
	Id string `json:"id"`

	// Memory The amount of memory in GiB.
	Memory int `json:"memory"`

	// Name The flavor name.
	Name string `json:"name"`
}

// OpenstackFlavors A list of OpenStack flavors.
type OpenstackFlavors = []OpenstackFlavor

// OpenstackImage And OpenStack image.
type OpenstackImage struct {
	// Created Time when the image was created. Images with a newer creation time should
	// be favoured over older images as they will contain updates and fewer vulnerabilities.
	Created time.Time `json:"created"`

	// Id The unique image ID.
	Id string `json:"id"`

	// Modified Time when the image was last modified.
	Modified time.Time `json:"modified"`

	// Name The image name.
	Name string `json:"name"`

	// Versions Image version metadata.
	Versions struct {
		// Kubernetes The kubernetes semantic version.  This should be used directly when specifying
		// Kubernetes control planes and workload pools in a cluster specification.
		Kubernetes string `json:"kubernetes"`

		// NvidiaDriver The nvidia driver version.
		NvidiaDriver string `json:"nvidiaDriver"`
	} `json:"versions"`
}

// OpenstackImages A list of OpenStack images that are compatible with this platform.
type OpenstackImages = []OpenstackImage

// OpenstackKeyPair An OpenStack SSH key pair.
type OpenstackKeyPair struct {
	// Name The key pair name.
	Name string `json:"name"`
}

// OpenstackKeyPairs A list of OpenStack key pairs.
type OpenstackKeyPairs = []OpenstackKeyPair

// OpenstackMachinePool A Kubernetes cluster machine.
type OpenstackMachinePool struct {
	// Disk An OpenStack volume.
	Disk *OpenstackVolume `json:"disk,omitempty"`

	// FlavorName OpenStack flavor name.
	FlavorName string `json:"flavorName"`

	// ImageName OpenStack image name.
	ImageName string `json:"imageName"`

	// Replicas Number of machines.
	Replicas int `json:"replicas"`

	// Version Kubernetes version. This should be derived from the image name as images
	// will be preloaded with containers for a specific Kubernetes version.
	Version string `json:"version"`
}

// OpenstackProject An OpenStack project.
type OpenstackProject struct {
	// Description A verbose description of the project.
	Description *string `json:"description,omitempty"`

	// Id The unique project ID.
	Id string `json:"id"`

	// Name The name of the project.
	Name string `json:"name"`
}

// OpenstackProjects A list of OpenStack projects.
type OpenstackProjects = []OpenstackProject

// OpenstackVolume An OpenStack volume.
type OpenstackVolume struct {
	// AvailabilityZone Volume availability zone. Overrides the cluster default.
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	// Size Disk size in GiB.
	Size int `json:"size"`
}

// TimeWindow A time window that wraps into the next day if required.
type TimeWindow struct {
	// End An hour of the day in UTC.
	End Hour `json:"end"`

	// Start An hour of the day in UTC.
	Start Hour `json:"start"`
}

// Token Oauth2 token result.
type Token struct {
	// AccessToken The opaque access token.
	AccessToken string `json:"access_token"`

	// ExpiresIn The time in seconds the token will last for.
	ExpiresIn int `json:"expires_in"`

	// IdToken An OIDC ID token.
	IdToken *string `json:"id_token,omitempty"`

	// TokenType How the access token is to be presented to the resource server.
	TokenType string `json:"token_type"`
}

// TokenRequestOptions oauth2 token endpoint.
type TokenRequestOptions struct {
	// ClientId Client ID. Required with the "code" grant type.
	ClientId *string `json:"client_id"`

	// Code Authorization code. Required with the "code" grant type.
	Code *string `json:"code"`

	// CodeVerifier Client code verifier. Required with the "code" grant type.
	CodeVerifier *string `json:"code_verifier"`

	// GrantType Supported grant type.  Must be either "code" or "password".
	GrantType string `json:"grant_type"`

	// Password Resource owner password. Required with the "password" grant type.
	Password *string `json:"password"`

	// RedirectUri Client redirect URI. Required with the "code" grant type.
	RedirectUri *string `json:"redirect_uri"`

	// Username Resource owner username. Required with the "password" grant type.
	Username *string `json:"username"`
	union    json.RawMessage
}

// TokenRequestOptions0 defines model for .
type TokenRequestOptions0 struct {
	GrantType *interface{} `json:"grant_type,omitempty"`
}

// TokenRequestOptions1 defines model for .
type TokenRequestOptions1 struct {
	GrantType *interface{} `json:"grant_type,omitempty"`
}

// TokenScope OpenStack token scope.
type TokenScope struct {
	// Project OpenStack token project scope.
	Project TokenScopeProject `json:"project"`
}

// TokenScopeProject OpenStack token project scope.
type TokenScopeProject struct {
	// Id OpenStack project ID.
	Id string `json:"id"`
}

// ClusterNameParameter A Kubernetes name. Must be a valid DNS containing only lower case characters, numbers or hyphens, start and end with a character or number, and be at most 63 characters in length.
type ClusterNameParameter = KubernetesNameParameter

// ControlPlaneNameParameter A Kubernetes name. Must be a valid DNS containing only lower case characters, numbers or hyphens, start and end with a character or number, and be at most 63 characters in length.
type ControlPlaneNameParameter = KubernetesNameParameter

// ApplicationBundleResponse A list of application bundles.
type ApplicationBundleResponse = ApplicationBundles

// BadRequestResponse Generic error message.
type BadRequestResponse = Oauth2Error

// ConflictResponse Generic error message.
type ConflictResponse = Oauth2Error

// ControlPlaneResponse A control plane.
type ControlPlaneResponse = ControlPlane

// ControlPlanesResponse A list of control planes.
type ControlPlanesResponse = ControlPlanes

// InternalServerErrorResponse Generic error message.
type InternalServerErrorResponse = Oauth2Error

// JwksResponse JSON web key set. This data type is defined by an external 3rd party standards
// committee. Consult the relevant documentation for further details.
type JwksResponse = JsonWebKeySet

// KubernetesClusterResponse Kubernetes cluster creation parameters.
type KubernetesClusterResponse = KubernetesCluster

// KubernetesClustersResponse A list of Kubernetes clusters.
type KubernetesClustersResponse = KubernetesClusters

// NotFoundResponse Generic error message.
type NotFoundResponse = Oauth2Error

// OpenstackBlockStorageAvailabilityZonesResponse A list of OpenStack availability zones.
type OpenstackBlockStorageAvailabilityZonesResponse = OpenstackAvailabilityZones

// OpenstackComputeAvailabilityZonesResponse A list of OpenStack availability zones.
type OpenstackComputeAvailabilityZonesResponse = OpenstackAvailabilityZones

// OpenstackExternalNetworksResponse A list of OpenStack external networks.
type OpenstackExternalNetworksResponse = OpenstackExternalNetworks

// OpenstackFlavorsResponse A list of OpenStack flavors.
type OpenstackFlavorsResponse = OpenstackFlavors

// OpenstackImagesResponse A list of OpenStack images that are compatible with this platform.
type OpenstackImagesResponse = OpenstackImages

// OpenstackKeyPairsResponse A list of OpenStack key pairs.
type OpenstackKeyPairsResponse = OpenstackKeyPairs

// OpenstackProjectsResponse A list of OpenStack projects.
type OpenstackProjectsResponse = OpenstackProjects

// TokenResponse Oauth2 token result.
type TokenResponse = Token

// UnauthorizedResponse Generic error message.
type UnauthorizedResponse = Oauth2Error

// CreateControlPlaneRequest A control plane.
type CreateControlPlaneRequest = ControlPlane

// CreateKubernetesClusterRequest Kubernetes cluster creation parameters.
type CreateKubernetesClusterRequest = KubernetesCluster

// TokenScopeRequest OpenStack token scope.
type TokenScopeRequest = TokenScope

// PostApiV1AuthOauth2TokensFormdataRequestBody defines body for PostApiV1AuthOauth2Tokens for application/x-www-form-urlencoded ContentType.
type PostApiV1AuthOauth2TokensFormdataRequestBody = TokenRequestOptions

// PostApiV1AuthTokensTokenJSONRequestBody defines body for PostApiV1AuthTokensToken for application/json ContentType.
type PostApiV1AuthTokensTokenJSONRequestBody = TokenScope

// PostApiV1ControlplanesJSONRequestBody defines body for PostApiV1Controlplanes for application/json ContentType.
type PostApiV1ControlplanesJSONRequestBody = ControlPlane

// PutApiV1ControlplanesControlPlaneNameJSONRequestBody defines body for PutApiV1ControlplanesControlPlaneName for application/json ContentType.
type PutApiV1ControlplanesControlPlaneNameJSONRequestBody = ControlPlane

// PostApiV1ControlplanesControlPlaneNameClustersJSONRequestBody defines body for PostApiV1ControlplanesControlPlaneNameClusters for application/json ContentType.
type PostApiV1ControlplanesControlPlaneNameClustersJSONRequestBody = KubernetesCluster

// PutApiV1ControlplanesControlPlaneNameClustersClusterNameJSONRequestBody defines body for PutApiV1ControlplanesControlPlaneNameClustersClusterName for application/json ContentType.
type PutApiV1ControlplanesControlPlaneNameClustersClusterNameJSONRequestBody = KubernetesCluster

// AsTokenRequestOptions0 returns the union data inside the TokenRequestOptions as a TokenRequestOptions0
func (t TokenRequestOptions) AsTokenRequestOptions0() (TokenRequestOptions0, error) {
	var body TokenRequestOptions0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenRequestOptions0 overwrites any union data inside the TokenRequestOptions as the provided TokenRequestOptions0
func (t *TokenRequestOptions) FromTokenRequestOptions0(v TokenRequestOptions0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenRequestOptions0 performs a merge with any union data inside the TokenRequestOptions, using the provided TokenRequestOptions0
func (t *TokenRequestOptions) MergeTokenRequestOptions0(v TokenRequestOptions0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsTokenRequestOptions1 returns the union data inside the TokenRequestOptions as a TokenRequestOptions1
func (t TokenRequestOptions) AsTokenRequestOptions1() (TokenRequestOptions1, error) {
	var body TokenRequestOptions1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenRequestOptions1 overwrites any union data inside the TokenRequestOptions as the provided TokenRequestOptions1
func (t *TokenRequestOptions) FromTokenRequestOptions1(v TokenRequestOptions1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenRequestOptions1 performs a merge with any union data inside the TokenRequestOptions, using the provided TokenRequestOptions1
func (t *TokenRequestOptions) MergeTokenRequestOptions1(v TokenRequestOptions1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TokenRequestOptions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ClientId != nil {
		object["client_id"], err = json.Marshal(t.ClientId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'client_id': %w", err)
		}
	}

	if t.Code != nil {
		object["code"], err = json.Marshal(t.Code)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'code': %w", err)
		}
	}

	if t.CodeVerifier != nil {
		object["code_verifier"], err = json.Marshal(t.CodeVerifier)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'code_verifier': %w", err)
		}
	}

	object["grant_type"], err = json.Marshal(t.GrantType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'grant_type': %w", err)
	}

	if t.Password != nil {
		object["password"], err = json.Marshal(t.Password)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'password': %w", err)
		}
	}

	if t.RedirectUri != nil {
		object["redirect_uri"], err = json.Marshal(t.RedirectUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redirect_uri': %w", err)
		}
	}

	if t.Username != nil {
		object["username"], err = json.Marshal(t.Username)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'username': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *TokenRequestOptions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["client_id"]; found {
		err = json.Unmarshal(raw, &t.ClientId)
		if err != nil {
			return fmt.Errorf("error reading 'client_id': %w", err)
		}
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &t.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
	}

	if raw, found := object["code_verifier"]; found {
		err = json.Unmarshal(raw, &t.CodeVerifier)
		if err != nil {
			return fmt.Errorf("error reading 'code_verifier': %w", err)
		}
	}

	if raw, found := object["grant_type"]; found {
		err = json.Unmarshal(raw, &t.GrantType)
		if err != nil {
			return fmt.Errorf("error reading 'grant_type': %w", err)
		}
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &t.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
	}

	if raw, found := object["redirect_uri"]; found {
		err = json.Unmarshal(raw, &t.RedirectUri)
		if err != nil {
			return fmt.Errorf("error reading 'redirect_uri': %w", err)
		}
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &t.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
	}

	return err
}
